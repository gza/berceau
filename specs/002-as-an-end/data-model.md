# Data Model: Component-Level Database Integration

**Feature**: `002-as-an-end` | **Date**: 2025-10-21

## Overview

This document describes the data entities and relationships for the component-level database integration feature. This feature is primarily a build-time infrastructure feature, so most "entities" are file-based artifacts rather than runtime database models. However, the demo component will include example database models to demonstrate the feature.

---

## Build-Time Entities

These entities exist as files and artifacts in the project structure during the build process.

### 1. Component Prisma Schema

**Location**: `src/components/{component-name}/prisma/schema.prisma`

**Purpose**: Defines a component's database models and enums

**Structure**:
```prisma
// ONLY models and enums
// NO datasource or generator blocks

model ComponentNameEntity {
  id        String   @id @default(uuid())
  field1    String
  field2    Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum ComponentNameStatus {
  VALUE1
  VALUE2
}
```

**Constraints**:
- MUST contain only model and enum definitions
- MUST NOT contain datasource or generator blocks
- MUST use valid Prisma schema syntax
- Model names MUST be unique across all components

**Lifecycle**:
1. Created by component developer
2. Discovered by build process during component discovery
3. Copied to central schema directory
4. Merged with other schemas by Prisma CLI

---

### 2. Central Main Schema

**Location**: `prisma/schema/main.prisma`

**Purpose**: Provides datasource and generator configuration for all component schemas

**Structure**:
```prisma
// Generated by build process - DO NOT EDIT MANUALLY

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}
```

**Constraints**:
- MUST be generated by build process (not manually edited)
- MUST reference DATABASE_URL environment variable
- MUST use PostgreSQL provider

**Lifecycle**:
1. Generated by build process
2. Written to `prisma/schema/main.prisma`
3. Read by Prisma CLI during `prisma generate` and `prisma migrate`

---

### 3. Copied Component Schema

**Location**: `prisma/schema/{component-name}.prisma`

**Purpose**: Central location for component schema files, enabling Prisma's multi-file schema feature

**Structure**: Identical to source component schema (models and enums only)

**Constraints**:
- MUST be exact copy of source schema
- MUST be generated by build process
- File name MUST be `{component-name}.prisma`

**Lifecycle**:
1. Generated by copying from `src/components/{component-name}/prisma/schema.prisma`
2. Written to `prisma/schema/{component-name}.prisma`
3. Automatically discovered by Prisma CLI (multi-file schema feature)
4. Merged with other schemas during `prisma generate`

---

### 4. Schema Discovery Metadata

**Location**: In-memory during build process (may be written to manifest file)

**Purpose**: Track discovered component schemas for build process

**Structure**:
```typescript
interface DiscoveredSchema {
  componentName: string;        // e.g., "demo"
  sourcePath: string;           // e.g., "src/components/demo/prisma/schema.prisma"
  destinationPath: string;      // e.g., "prisma/schema/demo.prisma"
  discovered: boolean;          // Whether schema file exists
}
```

**Lifecycle**:
1. Created during component discovery phase
2. Used to orchestrate schema copying
3. May be persisted to manifest file for debugging
4. Discarded after build completes

---

## Runtime Entities

These entities exist at runtime in the application.

### 5. Centralized Prisma Client

**Location**: `node_modules/.prisma/client` (generated by Prisma)

**Purpose**: Type-safe database client providing access to all models from all components

**Structure**: TypeScript interfaces and classes generated by Prisma

**Usage**:
```typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Access any model from any component
const users = await prisma.demoUser.findMany();
const posts = await prisma.demoPost.findMany();
```

**Constraints**:
- Generated code (do not edit manually)
- Single instance should be shared across application (singleton pattern)

**Lifecycle**:
1. Generated by `prisma generate` command
2. Imported by application code
3. Instantiated at runtime (typically as singleton service)
4. Used for all database operations

---

### 6. Prisma Service (NestJS)

**Location**: `src/database/runtime/prisma.service.ts`

**Purpose**: NestJS service wrapper around Prisma Client, providing lifecycle integration

**Structure**:
```typescript
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}
```

**Constraints**:
- MUST extend PrismaClient
- MUST implement NestJS lifecycle hooks
- SHOULD be registered as global provider

**Lifecycle**:
1. Registered in root NestJS module
2. Instantiated by NestJS DI container
3. Connected to database on module init
4. Injected into component services/controllers
5. Disconnected on module destroy

---

## Database Migration Entities

### 7. Prisma Migration Files

**Location**: `prisma/migrations/{timestamp}_{name}/`

**Purpose**: Version-controlled database schema changes

**Structure**:
```
prisma/migrations/
├── 20251021000000_init/
│   └── migration.sql
├── 20251021000001_add_demo_user/
│   └── migration.sql
└── migration_lock.toml
```

**Contents of migration.sql**:
```sql
-- CreateTable
CREATE TABLE "DemoUser" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "DemoUser_email_key" ON "DemoUser"("email");
```

**Lifecycle**:
1. Created by `prisma migrate dev --name <name>` command
2. Committed to version control
3. Applied to database by `prisma migrate dev` (development) or `prisma migrate deploy` (production)
4. Tracked in `_prisma_migrations` table in database

---

## Demo Component Database Models

To demonstrate the feature, the demo component will include example database models.

### 8. DemoUser Model

**Location**: `src/components/demo/prisma/schema.prisma`

**Purpose**: Example user entity for demo component

**Schema**:
```prisma
model DemoUser {
  id        String     @id @default(uuid())
  name      String     @unique
  email     String     @unique
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  posts     DemoPost[]
}
```

**Fields**:
- `id`: UUID primary key
- `name`: Unique user name (used for demo simplicity)
- `email`: Unique email address
- `createdAt`: Timestamp of creation
- `updatedAt`: Timestamp of last update
- `posts`: One-to-many relationship with DemoPost

**Validation Rules** (application-level, not database):
- Name must be at least 1 character
- Email must be valid email format (or auto-generated for demo)

---

### 9. DemoPost Model

**Location**: `src/components/demo/prisma/schema.prisma`

**Purpose**: Example post entity for demo component

**Schema**:
```prisma
model DemoPost {
  id        String         @id @default(uuid())
  title     String
  content   String?
  status    DemoPostStatus @default(DRAFT)
  authorId  String
  author    DemoUser       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  @@index([authorId])
}

enum DemoPostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}
```

**Fields**:
- `id`: UUID primary key
- `title`: Post title
- `content`: Optional post content
- `status`: Post publication status (enum)
- `authorId`: Foreign key to DemoUser
- `author`: Many-to-one relationship with DemoUser
- `createdAt`: Timestamp of creation
- `updatedAt`: Timestamp of last update

**Relationships**:
- Belongs to DemoUser (author)
- Cascade delete when user is deleted

**Indexes**:
- `authorId` for efficient user post queries

**State Transitions** (application-level):
- DRAFT → PUBLISHED: When post is published
- PUBLISHED → ARCHIVED: When post is archived
- ARCHIVED → PUBLISHED: When post is unarchived
- Any status → DRAFT: When post is reverted to draft

---

## Environment Configuration Entities

### 10. Database Connection Configuration

**Location**: `.env` file (local development) or environment variables (production)

**Purpose**: Provide database connection credentials

**Structure**:
```env
DATABASE_URL="postgresql://username:password@localhost:5432/dbname?schema=public"
MIGRATION_DATABASE_URL="postgresql://admin:password@localhost:5432/dbname?schema=public"
```

**Constraints**:
- MUST be valid PostgreSQL connection string
- MUST NOT be committed to version control
- SHOULD use different values for different environments

**Fields**:
- `DATABASE_URL`: Runtime database connection (may have limited permissions)
- `MIGRATION_DATABASE_URL`: Migration database connection (needs schema modification permissions)

---

## Entity Relationships

### Build-Time Relationships

```
Component Prisma Schema (source)
    ↓ [discovered by]
Schema Discovery Metadata
    ↓ [copied to]
Copied Component Schema (destination)
    ↓ [merged with]
Central Main Schema
    ↓ [used by]
prisma generate
    ↓ [produces]
Centralized Prisma Client
```

### Runtime Relationships

```
Centralized Prisma Client
    ↓ [extended by]
Prisma Service
    ↓ [injected into]
Component Controllers/Services
    ↓ [perform operations on]
Database Models (DemoUser, DemoPost, etc.)
```

### Migration Relationships

```
Component Prisma Schema
    ↓ [changes trigger]
prisma migrate dev
    ↓ [generates]
Migration Files
    ↓ [applied to]
Database
```

---

## Data Flow

### Build Process Data Flow

1. **Discovery Phase**:
   - Webpack scans `src/components/*/prisma/schema.prisma`
   - Creates Schema Discovery Metadata for each discovered schema

2. **Copy Phase**:
   - Each discovered schema copied to `prisma/schema/{component}.prisma`
   - Central Main Schema generated at `prisma/schema/main.prisma`

3. **Generation Phase**:
   - `prisma generate` reads all files in `prisma/schema/`
   - Merges models and enums from all files
   - Generates unified TypeScript Prisma Client

### Development Workflow Data Flow

1. **Developer modifies schema**: `src/components/demo/prisma/schema.prisma`
2. **Build process triggers**: Webpack detects change
3. **Schema copied**: Updated schema copied to `prisma/schema/demo.prisma`
4. **Client regenerated**: `prisma generate` produces new client
5. **Developer runs migration**: `npx prisma migrate dev --name change_description`
6. **Database updated**: Migration applied to database
7. **Application code uses new schema**: TypeScript types updated

### Runtime Data Flow

1. **Application starts**: NestJS initializes modules
2. **Prisma Service created**: DI container instantiates PrismaService
3. **Database connection**: `onModuleInit` connects to database
4. **Request arrives**: Controller receives HTTP request
5. **Service method called**: Controller delegates to service
6. **Database query**: Service uses Prisma Client (via injected PrismaService)
7. **Results returned**: Data flows back through service → controller → response

---

## Schema Validation Rules

### Component Schema Validation

Build process MUST validate that component schemas:
- Contain only `model` and `enum` definitions
- Do NOT contain `datasource` blocks
- Do NOT contain `generator` blocks
- Use valid Prisma schema syntax

### Main Schema Validation

Build process MUST ensure main schema:
- Contains exactly one `datasource` block
- Contains exactly one `generator` block
- References `env("DATABASE_URL")`
- Uses `provider = "postgresql"`

### Overall Schema Validation

After merging, Prisma CLI will validate:
- No duplicate model names
- No duplicate enum names
- Valid relationships and foreign keys
- Valid Prisma syntax

---

## Conflict Resolution

### Model Name Conflicts

**Problem**: Two components define models with the same name

**Detection**: Prisma `generate` command fails with error

**Resolution**:
- Build process SHOULD detect conflicts early and provide helpful error messages
- Developer MUST rename models to resolve conflicts
- Coordinate with other component developers when necessary

### Enum Name Conflicts

**Problem**: Two components define enums with the same name

**Detection**: Prisma `generate` command fails with error

**Resolution**: Same as model name conflicts

### Field Type Conflicts

**Problem**: Component uses unsupported PostgreSQL types

**Detection**: Prisma validation error

**Resolution**: Developer MUST use supported types or configure custom types

---

## Summary

This data model describes a build-time infrastructure feature with minimal runtime entities. The primary entities are:

**Build-time**:
- Component Prisma Schemas (source)
- Copied Component Schemas (destination)
- Central Main Schema (configuration)
- Schema Discovery Metadata (orchestration)

**Runtime**:
- Centralized Prisma Client (database access)
- Prisma Service (NestJS integration)

**Version Control**:
- Migration Files (schema evolution)

**Configuration**:
- Environment Variables (credentials)

**Demo**:
- DemoUser and DemoPost models (examples)

The feature enables component developers to define database schemas in their component directories, which are then compiled into a single centralized Prisma Client, providing type-safe database access across the entire application.
