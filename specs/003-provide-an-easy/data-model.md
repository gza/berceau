# Data Model: CSRF Token Protection

**Feature**: 003-provide-an-easy  
**Date**: 2025-10-24  
**Status**: Draft

## Overview

This document defines the data entities and their relationships for the CSRF token protection system. The implementation follows the Synchronizer Token Pattern with server-side session storage.

## Entities

### 1. CSRF Token

**Description**: Cryptographically secure random string bound to a user session, used to verify request authenticity.

**Properties**:
- **value**: `string` (64 hex characters, 256 bits of entropy)
  - Generated using `crypto.randomBytes(32).toString('hex')`
  - Stored in server-side session storage
  - Never transmitted except as hidden form fields or HTTP headers
  
**Lifecycle**:
1. **Generation**: Created when first needed (lazy generation on `<CsrfToken />` render)
2. **Storage**: Stored in Express session under key `_csrf`
3. **Transmission**: Sent to client as hidden input or meta tag
4. **Validation**: Compared against session token using constant-time algorithm
5. **Expiration**: Bound to session lifetime (24 hours by default)

**Storage Format** (in session):
```typescript
interface SessionData {
  _csrf?: string; // CSRF token value
  // ... other session properties
}
```

**Security Constraints**:
- MUST be generated using cryptographically secure random number generator
- MUST be stored server-side (never in cookies or localStorage)
- MUST use constant-time comparison to prevent timing attacks
- MUST be bound to user session
- MUST expire when session expires

**Example**:
```typescript
{
  value: "a3f8d9e2b1c4567890abcdef12345678fedcba0987654321abcdef1234567890"
}
```

---

### 2. Session

**Description**: Server-side session storage containing user authentication state and CSRF token. Managed by `express-session` middleware.

**Properties**:
- **id**: `string` - Unique session identifier (generated by express-session)
- **csrfToken**: `string` - Current CSRF token for this session
- **createdAt**: `Date` - Session creation timestamp
- **expiresAt**: `Date` - Session expiration timestamp

**Storage Backend**:
- **Development**: MemoryStore (sessions lost on server restart)
- **Production**: Redis or PostgreSQL (persistent, scalable)

**Session Cookie** (managed by express-session):
```typescript
{
  name: 'connect.sid',          // Cookie name
  value: 's:abc123...signature', // Signed session ID
  httpOnly: true,                // Not accessible to JavaScript
  secure: true,                  // HTTPS only (production)
  sameSite: 'lax',               // CSRF protection
  maxAge: 86400000               // 24 hours in milliseconds
}
```

**Relationships**:
- **One session** → **One CSRF token** (1:1)

**State Transitions**:
```
[New Session] 
    ↓ (User visits site)
[Active Session without Token]
    ↓ (Page with form is rendered)
[Active Session with Token]
    ↓ (User logs out OR session expires)
[Expired Session]
    ↓ (Garbage collection)
[Deleted]
```

**Example Session Data**:
```typescript
{
  id: 'abc123def456',
  _csrf: 'a3f8d9e2b1c4567890abcdef12345678fedcba0987654321abcdef1234567890',
  cookie: {
    originalMaxAge: 86400000,
    expires: '2025-10-25T12:00:00.000Z',
    httpOnly: true,
    secure: true,
    sameSite: 'lax'
  }
}
```

---

### 3. Request Context

**Description**: Runtime context for an incoming HTTP request, containing session information and CSRF token for validation.

**Properties**:
- **method**: `HTTPMethod` - HTTP method (GET, POST, PUT, DELETE, PATCH, etc.)
- **path**: `string` - Request URL path
- **session**: `Session` - Associated session object
- **csrfTokenFromRequest**: `string | undefined` - CSRF token submitted with request
- **csrfTokenLocation**: `'body' | 'query' | 'header' | undefined` - Where token was found
- **skipCsrfValidation**: `boolean` - Whether route has @SkipCsrf() decorator

**Token Extraction Priority**:
1. Request body: `req.body._csrf`
2. HTTP header: `req.headers['x-csrf-token']` (lowercase - Express normalizes headers)
3. Query parameter: `req.query._csrf` (fallback)

**Validation Rules**:
```typescript
interface ValidationContext {
  // Safe methods never require CSRF validation
  isSafeMethod: boolean; // GET, HEAD, OPTIONS
  
  // Routes can opt out of CSRF validation
  hasSkipCsrfDecorator: boolean;
  
  // Token must exist in both session and request
  hasSessionToken: boolean;
  hasRequestToken: boolean;
  
  // Tokens must match using constant-time comparison
  tokensMatch: boolean;
}

// Validation logic:
// isValid = isSafeMethod 
//           || hasSkipCsrfDecorator 
//           || (hasSessionToken && hasRequestToken && tokensMatch)
```

**Example**:
```typescript
{
  method: 'POST',
  path: '/demo/posts',
  session: {
    id: 'abc123',
    _csrf: 'a3f8d9e2b1c4567890...'
  },
  csrfTokenFromRequest: 'a3f8d9e2b1c4567890...',
  csrfTokenLocation: 'body',
  skipCsrfValidation: false
}
```

---

### 4. CSRF Configuration

**Description**: Application-wide configuration settings for CSRF protection behavior.

**Properties**:
- **tokenLength**: `number` - Byte length of generated tokens (default: 32 bytes = 256 bits)
- **sessionKey**: `string` - Key used to store token in session (default: '_csrf')
- **fieldName**: `string` - HTML form field name for token (default: '_csrf')
- **headerName**: `string` - HTTP header name for token (default: 'X-CSRF-Token')
- **cookieName**: `string` - Session cookie name (default: 'connect.sid')
- **safeMethods**: `Set<string>` - HTTP methods exempt from validation (default: GET, HEAD, OPTIONS)

**Defaults** (following OWASP recommendations):
```typescript
const DEFAULT_CSRF_CONFIG = {
  tokenLength: 32,           // 256-bit tokens
  sessionKey: '_csrf',       // Session storage key
  fieldName: '_csrf',        // HTML input name
  headerName: 'X-CSRF-Token', // HTTP header name (config uses standard capitalization)
  cookieName: 'connect.sid', // Session cookie name
  safeMethods: new Set(['GET', 'HEAD', 'OPTIONS'])
} as const;
```

**Validation Constraints**:
- `tokenLength` MUST be ≥ 16 bytes (128 bits minimum per OWASP)
- `sessionKey` MUST NOT conflict with other session properties
- `safeMethods` MUST include GET, HEAD, OPTIONS at minimum
- Configuration MUST be immutable after application bootstrap

**Example Configuration**:
```typescript
{
  tokenLength: 32,
  sessionKey: '_csrf',
  fieldName: '_csrf',
  headerName: 'X-CSRF-Token',
  cookieName: 'connect.sid',
  safeMethods: new Set(['GET', 'HEAD', 'OPTIONS'])
}
```

---

### 5. Validation Result

**Description**: Result of CSRF token validation, including success status and diagnostic information.

**Properties**:
- **isValid**: `boolean` - Whether validation passed
- **reason**: `ValidationFailureReason | undefined` - Why validation failed (if applicable)
- **tokenPresent**: `boolean` - Whether token was found in request
- **sessionPresent**: `boolean` - Whether session exists
- **timestamp**: `Date` - When validation occurred

**Validation Failure Reasons**:
```typescript
enum ValidationFailureReason {
  NO_SESSION = 'NO_SESSION',                   // Request has no session
  NO_SESSION_TOKEN = 'NO_SESSION_TOKEN',       // Session has no CSRF token
  NO_REQUEST_TOKEN = 'NO_REQUEST_TOKEN',       // Request missing CSRF token
  TOKEN_MISMATCH = 'TOKEN_MISMATCH',           // Tokens don't match
  INVALID_TOKEN_FORMAT = 'INVALID_TOKEN_FORMAT' // Token format is invalid
}
```

**Usage**:
```typescript
const result: ValidationResult = csrfService.validate(request);

if (!result.isValid) {
  logger.warn('CSRF validation failed', {
    reason: result.reason,
    path: request.path,
    method: request.method,
    sessionId: request.session?.id,
    timestamp: result.timestamp
  });
  
  throw new ForbiddenException('Invalid or missing CSRF token');
}
```

**Example**:
```typescript
// Success case:
{
  isValid: true,
  reason: undefined,
  tokenPresent: true,
  sessionPresent: true,
  timestamp: new Date('2025-10-24T12:00:00Z')
}

// Failure case:
{
  isValid: false,
  reason: ValidationFailureReason.TOKEN_MISMATCH,
  tokenPresent: true,
  sessionPresent: true,
  timestamp: new Date('2025-10-24T12:00:00Z')
}
```

---

## Relationships

### Entity Relationship Diagram

```
┌─────────────────┐
│     Session     │
│                 │
│ - id            │
│ - csrfToken     │───────┐
│ - createdAt     │       │
│ - expiresAt     │       │ 1:1
└─────────────────┘       │
                          │
                          ▼
                    ┌────────────────┐
                    │   CSRF Token   │
                    │                │
                    │ - value (hex)  │
                    │ - generatedAt  │
                    └────────────────┘
                              │
                              │ used in
                              │
                              ▼
                    ┌──────────────────────┐
                    │  Request Context     │
                    │                      │
                    │ - method             │
                    │ - path               │
                    │ - session            │
                    │ - csrfTokenFromReq   │
                    │ - skipCsrfValidation │
                    └──────────────────────┘
                              │
                              │ validates using
                              │
                              ▼
                    ┌──────────────────────┐
                    │  Validation Result   │
                    │                      │
                    │ - isValid            │
                    │ - reason             │
                    │ - timestamp          │
                    └──────────────────────┘

                    ┌──────────────────────┐
                    │  CSRF Configuration  │
                    │   (singleton)        │
                    │                      │
                    │ - tokenLength        │
                    │ - sessionKey         │
                    │ - fieldName          │
                    │ - headerName         │
                    └──────────────────────┘
                              │
                              │ used by all
                              │ components
```

### Cardinality

- **Session : CSRF Token** = 1:1 (each session has exactly one token, generated lazily)
- **Request : Session** = 1:1 (every request has a session, created if needed)
- **Request : ValidationResult** = 1:1 (every validation produces a result)
- **Application : Configuration** = 1:1 (single global configuration)

---

## Data Flow

### Token Generation Flow

```
1. User requests page with form
   ↓
2. Controller calls renderPage()
   ↓
3. <CsrfToken /> component rendered
   ↓
4. Component requests token from CsrfService
   ↓
5. CsrfService checks session for existing token
   ↓
6. If no token exists:
   a. Generate random token using crypto.randomBytes(32)
   b. Store in session: session._csrf = token
   ↓
7. Return token to component
   ↓
8. Component renders: <input type="hidden" name="_csrf" value="{token}" />
   ↓
9. HTML sent to browser with embedded token
```

### Token Validation Flow

```
1. User submits form (POST request)
   ↓
2. Request received by NestJS
   ↓
3. Express session middleware loads session
   ↓
4. CsrfGuard.canActivate() invoked
   ↓
5. Guard checks for @SkipCsrf() decorator
   ├─ If present: allow request (return true)
   └─ If absent: continue validation
   ↓
6. Guard checks HTTP method
   ├─ If safe method (GET, HEAD, OPTIONS): allow request
   └─ If unsafe method: continue validation
   ↓
7. CsrfService.validateToken() invoked
   ↓
8. Service extracts token from request:
   a. Check req.body._csrf
   b. Check req.headers['x-csrf-token']  (lowercase - Express normalizes all headers)
   c. Check req.query._csrf
   ↓
9. Service retrieves token from session
   ↓
10. Service compares tokens using constant-time algorithm
    ├─ If match: return true (validation passed)
    └─ If no match: return false (validation failed)
    ↓
11. Guard returns result to NestJS
    ├─ If true: request proceeds to controller
    └─ If false: throw ForbiddenException (403)
```

---

## Storage Considerations

### Session Store Options

**Development**:
```typescript
// MemoryStore (default, non-persistent)
import * as session from 'express-session';

app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  // No store specified = MemoryStore
}));
```

**Production (Redis)**:
```typescript
import * as session from 'express-session';
import RedisStore from 'connect-redis';
import { createClient } from 'redis';

const redisClient = createClient({
  url: process.env.REDIS_URL
});
await redisClient.connect();

app.use(session({
  store: new RedisStore({ client: redisClient }),
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    maxAge: 24 * 60 * 60 * 1000, // 24 hours
    httpOnly: true,
    secure: true,
    sameSite: 'lax'
  }
}));
```

**Production (PostgreSQL)**:
```typescript
import * as session from 'express-session';
import connectPgSimple from 'connect-pg-simple';
import { Pool } from 'pg';

const PgSession = connectPgSimple(session);
const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

app.use(session({
  store: new PgSession({
    pool,
    tableName: 'sessions' // Will be auto-created
  }),
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    maxAge: 24 * 60 * 60 * 1000,
    httpOnly: true,
    secure: true,
    sameSite: 'lax'
  }
}));
```

---

## Security Properties

### Threat Model

**Threats Mitigated**:
1. **Cross-Site Request Forgery (CSRF)**: Primary threat - attacker tricks user into submitting forged requests
2. **Session Fixation**: Mitigated by regenerating session ID on authentication (express-session feature)
3. **Token Prediction**: Impossible due to cryptographic randomness (256 bits entropy)

**Threats NOT Mitigated** (out of scope):
1. **XSS Attacks**: Requires separate mitigation (CSP, input sanitization)
2. **Man-in-the-Middle**: Requires HTTPS (handled at infrastructure level)
3. **Session Hijacking**: Requires secure cookie settings and network security

### Validation Rules

**Rule 1**: Safe HTTP methods MUST bypass CSRF validation
```typescript
const safeMethods = ['GET', 'HEAD', 'OPTIONS'];
if (safeMethods.includes(request.method)) {
  return true; // No validation needed
}
```

**Rule 2**: Routes with @SkipCsrf() MUST bypass validation
```typescript
if (reflector.get(SKIP_CSRF_KEY, context.getHandler())) {
  return true; // Explicit opt-out
}
```

**Rule 3**: Token MUST exist in both session and request
```typescript
if (!session._csrf || !requestToken) {
  throw new ForbiddenException('Missing CSRF token');
}
```

**Rule 4**: Tokens MUST match using constant-time comparison
```typescript
import { timingSafeEqual } from 'crypto';

function validateToken(sessionToken: string, requestToken: string): boolean {
  try {
    return timingSafeEqual(
      Buffer.from(sessionToken, 'utf8'),
      Buffer.from(requestToken, 'utf8')
    );
  } catch {
    return false; // Handle any unexpected errors
  }
}
```

---

## Appendix: TypeScript Interfaces

```typescript
// Core types
export interface CsrfToken {
  value: string; // 64 hex characters
}

export interface CsrfConfiguration {
  tokenLength: number;
  sessionKey: string;
  fieldName: string;
  headerName: string;
  cookieName: string;
  safeMethods: Set<string>;
}

export interface RequestContext {
  method: string;
  path: string;
  session: any; // Express session type
  csrfTokenFromRequest?: string;
  csrfTokenLocation?: 'body' | 'query' | 'header';
  skipCsrfValidation: boolean;
}

export interface ValidationResult {
  isValid: boolean;
  reason?: ValidationFailureReason;
  tokenPresent: boolean;
  sessionPresent: boolean;
  timestamp: Date;
}

export enum ValidationFailureReason {
  NO_SESSION = 'NO_SESSION',
  NO_SESSION_TOKEN = 'NO_SESSION_TOKEN',
  NO_REQUEST_TOKEN = 'NO_REQUEST_TOKEN',
  TOKEN_MISMATCH = 'TOKEN_MISMATCH',
  INVALID_TOKEN_FORMAT = 'INVALID_TOKEN_FORMAT'
}
```
