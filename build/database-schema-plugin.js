/**
 * Database Schema Plugin for Webpack
 *
 * Discovers component Prisma schemas at build time, copies them to central
 * schema directory, generates main.prisma, and triggers Prisma Client generation.
 */

const fs = require("fs")
const path = require("path")
const { execSync } = require("child_process")

class DatabaseSchemaPlugin {
  constructor(options = {}) {
    this.rootDir = options.rootDir || process.cwd()
    this.componentsDir = path.join(this.rootDir, "src", "components")
    this.schemaOutputDir = path.join(this.rootDir, "prisma", "schema")
  }

  apply(compiler) {
    compiler.hooks.beforeCompile.tapAsync(
      "DatabaseSchemaPlugin",
      (params, callback) => {
        try {
          console.log("[DatabaseSchema] Starting schema discovery...")

          // Discover all component schemas
          const schemas = this.discoverSchemas()

          if (schemas.length === 0) {
            console.log("[DatabaseSchema] No component schemas found")
            callback()
            return
          }

          console.log(
            `[DatabaseSchema] Discovered ${schemas.length} schema(s)`,
          )

          // Clean old schema files (except main.prisma)
          this.cleanSchemaDirectory()

          // Copy schemas to central directory
          this.copySchemas(schemas)

          // Generate main.prisma
          this.generateMainSchema()

          // Generate Prisma Client
          this.generatePrismaClient()

          console.log(
            "[DatabaseSchema] Schema processing complete",
          )
          callback()
        } catch (error) {
          console.error("[DatabaseSchema] Error during schema processing:", error)
          callback(error)
        }
      },
    )

    // Watch component directories for schema changes
    compiler.hooks.afterCompile.tap("DatabaseSchemaPlugin", (compilation) => {
      compilation.contextDependencies.add(this.componentsDir)
    })
  }

  /**
   * Discover all Prisma schema files in component directories
   */
  discoverSchemas() {
    const schemas = []

    if (!fs.existsSync(this.componentsDir)) {
      return schemas
    }

    const discoverInDir = (dir) => {
      const entries = fs.readdirSync(dir, { withFileTypes: true })

      for (const entry of entries) {
        if (!entry.isDirectory() || entry.name.startsWith(".")) {
          continue
        }

        if (
          entry.name === "components.generated" ||
          entry.name === "node_modules"
        ) {
          continue
        }

        const fullPath = path.join(dir, entry.name)
        const schemaPath = path.join(fullPath, "prisma", "schema.prisma")

        if (fs.existsSync(schemaPath)) {
          const componentName = entry.name
          const destinationPath = path.join(
            this.schemaOutputDir,
            `${componentName}.prisma`,
          )

          schemas.push({
            componentName,
            sourcePath: schemaPath,
            destinationPath,
          })
        } else {
          // Recursively search subdirectories
          discoverInDir(fullPath)
        }
      }
    }

    discoverInDir(this.componentsDir)
    return schemas
  }

  /**
   * Clean the schema output directory (remove component schemas, keep main.prisma)
   */
  cleanSchemaDirectory() {
    if (!fs.existsSync(this.schemaOutputDir)) {
      return
    }

    const files = fs.readdirSync(this.schemaOutputDir)

    for (const file of files) {
      if (this.shouldPreserveFile(file)) {
        continue
      }

      const filePath = path.join(this.schemaOutputDir, file)
      fs.unlinkSync(filePath)
    }
  }

  /**
   * Determine if a file should be preserved during schema directory cleanup
   * @param {string} file - The filename to check
   * @returns {boolean} True if the file should be kept, false if it should be deleted
   */
  shouldPreserveFile(file) {
    return file === "main.prisma" || file === ".gitkeep" || !file.endsWith(".prisma")
  }

  /**
   * Copy discovered schemas to central schema directory
   */
  copySchemas(schemas) {
    // Ensure output directory exists
    if (!fs.existsSync(this.schemaOutputDir)) {
      fs.mkdirSync(this.schemaOutputDir, { recursive: true })
    }

    for (const schema of schemas) {
      fs.copyFileSync(schema.sourcePath, schema.destinationPath)
      console.log(`[DatabaseSchema] Copied: ${schema.componentName}.prisma`)
    }
  }

  /**
   * Generate main.prisma with datasource and generator blocks
   */
  generateMainSchema() {
    const mainSchemaPath = path.join(this.schemaOutputDir, "main.prisma")

    const content = `// This file is auto-generated by the build process
// DO NOT EDIT MANUALLY - Changes will be overwritten

datasource db {
  provider = "postgresql"
  url      = env("MIGRATION_DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}
`

    fs.writeFileSync(mainSchemaPath, content, "utf8")
    console.log("[DatabaseSchema] Generated: main.prisma")
  }

  /**
   * Generate Prisma Client
   */
  generatePrismaClient() {
    try {
      // Use prisma.config.ts to specify schema directory (multi-file schema support)
      const command = `npx prisma generate`

      console.log(`[DatabaseSchema] Running: ${command}`)

      execSync(command, {
        cwd: this.rootDir,
        stdio: "inherit",
      })

      console.log("[DatabaseSchema] Prisma Client generated successfully")
    } catch (error) {
      console.error("[DatabaseSchema] Failed to generate Prisma Client:", error.message)
      throw error
    }
  }
}

module.exports = DatabaseSchemaPlugin
